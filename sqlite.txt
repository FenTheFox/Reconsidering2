(coppied from honors thesis)
memsys5:
Let n be the size of the largest allocation divided by the minimum allocation size (after rounding all sizes up to a power of 2.) Let M be the maximum amount of memory ever outstanding at one time. Let N be the total amount of memory available for allocation. Robson [10] proved that this memory allocator [memsys5 is based on the allocator he presented in the paper] will never breakdown due to fragmentation as long as the constraint ğ‘ >= ğ‘€âˆ—(1 +ğ‘™ğ‘œğ‘”2(ğ‘›)2)âˆ’ ğ‘› + 1 holds.

memsys3:
Memsys3 uses a header based freelist approach where each chunk (allocation) consists of two or more 8 byte blocks. The first block always contains the maximum size of the chunk and, if it is allocated, the current size of the chunk. If the chunk is free the second block contains a pointer to the next and previous free chunks. An array of pointers to the head of each free list is kept for small chunk sizes and a map of <size,pointer> pairs is kept for pointers to larger chunks. To satisfy allocation requests the allocator first looks for an existing free chunk, if one does not exist it tries to carve a chunk off of the master unallocated pool. If there isnâ€™t enough room there than it tries to coalesce each free list, adding coalesced chunks to the correct free list. During this process if it finds or coalesces a chunk that is larger than the current master the current master is replaced and the previous one is linked into the correct list. If there is still not enough memory the allocator returns null. 